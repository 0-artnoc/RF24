<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<title>RF24: starping_relay.pde</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css"/>
</head>
<body onload='searchBox.OnSelectItem(0);'>
<!-- Generated by Doxygen 1.7.3 -->
<script type="text/javascript"><!--
var searchBox = new SearchBox("searchBox", "search",false,'Search');
--></script>
<div id="top">
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td style="padding-left: 0.5em;">
   <div id="projectname">RF24&#160;<span id="projectnumber">v1</span></div>
  </td>
 </tr>
 </tbody>
</table>
</div>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li><a href="examples.html"><span>Examples</span></a></li>
      <li id="searchli">
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
</div>
<div class="header">
  <div class="headertitle">
<h1>starping_relay.pde</h1>  </div>
</div>
<div class="contents">
<p>This sketch is a very complex example of using the <a class="el" href="classRF24.html" title="Driver for nRF24L01(+) 2.4GHz Wireless Transceiver.">RF24</a> library for Arduino. Deploy this on any number of nodes to create a basic mesh network. I have tested this on 6 nodes, but it should work on many more. 'Leaf' nodes attempt to send a ping every 2 seconds to the 'Base' node. Optional 'Relay' nodes will relay these transmissions.</p>
<div class="fragment"><pre class="fragment"><span class="comment">/*</span>
<span class="comment"> Copyright (C) 2011 James Coliz, Jr. &lt;maniacbug@ymail.com&gt;</span>
<span class="comment"> </span>
<span class="comment"> This program is free software; you can redistribute it and/or</span>
<span class="comment"> modify it under the terms of the GNU General Public License</span>
<span class="comment"> version 2 as published by the Free Software Foundation.</span>
<span class="comment"> */</span>

<span class="preprocessor">#include &lt;SPI.h&gt;</span>
<span class="preprocessor">#include &lt;EEPROM.h&gt;</span>
<span class="preprocessor">#include &quot;nRF24L01.h&quot;</span>
<span class="preprocessor">#include &quot;RF24.h&quot;</span>
<span class="preprocessor">#include &quot;printf.h&quot;</span>

<span class="comment">//</span>
<span class="comment">// Hardware configuration</span>
<span class="comment">//</span>

<span class="comment">// Set up nRF24L01 radio on SPI bus plus pins 8 &amp; 9</span>

<a name="_a0"></a><a class="code" href="classRF24.html" title="Driver for nRF24L01(+) 2.4GHz Wireless Transceiver.">RF24</a> radio(8,9);

<span class="comment">//</span>
<span class="comment">// Topology</span>
<span class="comment">//</span>

<span class="keyword">struct </span>node_info
{
  uint64_t talking_pipe; <span class="comment">// Pipe used to talk to parent node</span>
  uint64_t listening_pipe; <span class="comment">// Pipe used to listen to parent node</span>
  uint8_t parent_node; <span class="comment">// Address of parent node</span>
};

<span class="keyword">const</span> node_info topology[] =
{
  { 0x0000000000LL, 0x0000000000LL,-1 }, <span class="comment">// Base</span>
  { 0xF0F0F0F0E1LL, 0x3A3A3A3AE1LL, 0 }, <span class="comment">// Relay</span>
  { 0xF0F0F0F0D2LL, 0x3A3A3A3AD2LL, 1 }, <span class="comment">// Leaf</span>
  { 0xF0F0F0F0C3LL, 0x3A3A3A3AC3LL, 1 }, <span class="comment">// Leaf</span>
  { 0xF0F0F0F0B4LL, 0x3A3A3A3AB4LL, 1 }, <span class="comment">// Leaf</span>
  { 0xF0F0F0F0A5LL, 0x3A3A3A3AA5LL, 0 }, <span class="comment">// Leaf, direct to Base</span>
};
<span class="keyword">const</span> <span class="keywordtype">short</span> num_nodes = <span class="keyword">sizeof</span>(topology)/<span class="keyword">sizeof</span>(node_info);

uint8_t find_node( uint8_t current_node, uint8_t target_node )
{
  uint8_t out_node = target_node;
  <span class="keywordtype">bool</span> found_target = <span class="keyword">false</span>;
  <span class="keywordflow">while</span> ( ! found_target )
  {
    <span class="keywordflow">if</span> ( topology[out_node].parent_node == current_node )
    {
      found_target = <span class="keyword">true</span>; 
    }
    <span class="keywordflow">else</span>
    {
      out_node = topology[out_node].parent_node;

      <span class="comment">// If we&#39;ve made it all the way back to the base without finding</span>
      <span class="comment">// common lineage with the to_node, we will just send it to our parent</span>
      <span class="keywordflow">if</span> ( out_node == 0 || out_node == -1 )
      {
        out_node = topology[current_node].parent_node;
        found_target = <span class="keyword">true</span>;
      }
    }
  }
  <span class="keywordflow">return</span> out_node;
}

<span class="comment">//</span>
<span class="comment">// Role management</span>
<span class="comment">//</span>
<span class="comment">// Set up role.  This sketch uses the same software for all the nodes</span>
<span class="comment">// in this system.  Doing so greatly simplifies testing.  Role is</span>
<span class="comment">// determined by the topology table.</span>
<span class="comment">//</span>

<span class="comment">// The various roles supported by this sketch</span>
<span class="keyword">typedef</span> <span class="keyword">enum</span> { role_invalid = 0, role_base, role_relay, role_leaf } role_e;

<span class="comment">// The debug-friendly names of those roles</span>
<span class="keyword">const</span> <span class="keywordtype">char</span>* role_friendly_name[] = { <span class="stringliteral">&quot;invalid&quot;</span>, <span class="stringliteral">&quot;Base&quot;</span>, <span class="stringliteral">&quot;Relay&quot;</span>, <span class="stringliteral">&quot;Leaf&quot;</span> };

<span class="comment">// The role of the current running sketch</span>
role_e role;

<span class="comment">//</span>
<span class="comment">// Address management</span>
<span class="comment">//</span>

<span class="comment">// Where in EEPROM is the address stored?</span>
<span class="keyword">const</span> uint8_t address_at_eeprom_location = 0;

<span class="comment">// What flag value is stored there so we know the value is valid?</span>
<span class="keyword">const</span> uint8_t valid_eeprom_flag = 0xdf;

<span class="comment">// What is our address (SRAM cache of the address from EEPROM)</span>
<span class="comment">// This is an index into the topology[] table above</span>
uint8_t node_address = -1;

<span class="comment">//</span>
<span class="comment">// Payload</span>
<span class="comment">//</span>

<span class="keyword">struct </span>payload_t
{
  uint8_t from_node;
  uint8_t to_node;
  uint16_t id;
  <span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> time;
  
  <span class="keyword">static</span> uint16_t next_id;
  
  payload_t(<span class="keywordtype">void</span>) {}
  payload_t(uint8_t _from, uint8_t _to, <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">long</span>&amp; _time): from_node(_from), to_node(_to), id(next_id++), time(_time) {}
};

uint16_t payload_t::next_id;

<span class="keywordtype">void</span> payload_printf(<span class="keyword">const</span> <span class="keywordtype">char</span>* name, <span class="keyword">const</span> payload_t&amp; pl)
{
  printf(<span class="stringliteral">&quot;%s Payload from:%u to:%u id:%u time:%lu&quot;</span>,name,pl.from_node,pl.to_node,pl.id,pl.time);
}

<span class="comment">//</span>
<span class="comment">// Setup/loop shared statics</span>
<span class="comment">//</span>

<span class="keyword">static</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> last_ping_sent_at;
<span class="keyword">static</span> <span class="keywordtype">bool</span> waiting_for_pong = <span class="keyword">false</span>;
<span class="keyword">static</span> <span class="keywordtype">short</span> consecutive_timeouts;
<span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> ping_interval = 2000; <span class="comment">// ms</span>
<span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> pong_timeout = 250; <span class="comment">// ms</span>
<span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> ping_phase_shift = 100; <span class="comment">// ms</span>
<span class="keyword">const</span> <span class="keywordtype">short</span> timeout_shift_threshold = 3;

<span class="comment">// Space to track the last packet we received from each node, useful</span>
<span class="comment">// for tracking lost packets</span>
<span class="keyword">static</span> uint16_t last_id_received[num_nodes];

<span class="keywordtype">void</span> setup(<span class="keywordtype">void</span>)
{
  <span class="comment">//</span>
  <span class="comment">// Address</span>
  <span class="comment">//</span>

  <span class="comment">// Look for the token in EEPROM to indicate the following value is</span>
  <span class="comment">// a validly set node address </span>
  <span class="keywordflow">if</span> ( EEPROM.read(address_at_eeprom_location) == valid_eeprom_flag )
  {
    <span class="comment">// Read the address from EEPROM</span>
    uint8_t reading = EEPROM.read(address_at_eeprom_location+1);

    <span class="comment">// If it is in a valid range for node addresses, it is our</span>
    <span class="comment">// address.</span>
    <span class="keywordflow">if</span> ( reading &lt;= 5 )
      node_address = reading;
  } 
  
  <span class="comment">//</span>
  <span class="comment">// Role</span>
  <span class="comment">//</span>

  <span class="comment">// Role is determined by address.</span>
  <span class="keywordflow">if</span> ( node_address != -1 )
  {
    <span class="comment">// Node #0 is the base, by definition</span>
    <span class="keywordflow">if</span> ( node_address == 0 )
      role = role_base;
    <span class="keywordflow">else</span>
    {
      <span class="comment">// Otherwise, it is probably a leaf node</span>
      role = role_leaf;

      <span class="comment">// If there are any nodes in the topology table which consider this</span>
      <span class="comment">// a parent, then we are a relay.</span>
      <span class="keywordtype">int</span> i = num_nodes;
      <span class="keywordflow">while</span> (i--)
      {
        <span class="keywordflow">if</span> ( topology[i].parent_node == node_address )
        {
          role = role_relay;
          <span class="keywordflow">break</span>;
        }
      }
    }
  }

  <span class="comment">//</span>
  <span class="comment">// Print preamble</span>
  <span class="comment">//</span>
  
  Serial.begin(9600);
  printf_begin();
  printf(<span class="stringliteral">&quot;\n\rRF24/examples/starping_relay/\n\r&quot;</span>);
  printf(<span class="stringliteral">&quot;ROLE: %s\n\r&quot;</span>,role_friendly_name[role]);
  printf(<span class="stringliteral">&quot;ADDRESS: %i\n\r&quot;</span>,node_address);

  <span class="comment">//</span>
  <span class="comment">// Setup and configure rf radio</span>
  <span class="comment">//</span>
  
  radio.begin();

  <span class="comment">//</span>
  <span class="comment">// Open pipes to other nodes for communication</span>
  <span class="comment">//</span>
  
  <span class="comment">// Each leaf node has a talking pipe that it will ping into, and a listening </span>
  <span class="comment">// pipe that it will listen for the pong.  Relay nodes also do this.</span>
  <span class="keywordflow">if</span> ( role == role_leaf )
  {
    <span class="comment">// Write on our talking pipe</span>
    radio.openWritingPipe(topology[node_address].talking_pipe);
    
    <span class="comment">// Listen on our listening pipe </span>
    radio.openReadingPipe(1,topology[node_address].listening_pipe);
  }
 
  <span class="comment">// Relay nodes have a special function.  They open their listening pipe on pipe</span>
  <span class="comment">// #0.  This will get over-written every time we open a writing pipe.  So</span>
  <span class="comment">// Remember to re-open the reading pipe whenever we start to listen again.</span>
  <span class="keywordflow">if</span> ( role == role_relay )
  { 
    <span class="comment">// Write on our talking pipe</span>
    radio.openWritingPipe(topology[node_address].talking_pipe);
    
    <span class="comment">// Listen on our listening pipe </span>
    radio.openReadingPipe(0,topology[node_address].listening_pipe);
  }

  <span class="comment">// The base and relay nodes listen on all their children node&#39;s talking pipes</span>
  <span class="comment">// and sends the pong back on the child node&#39;s specific listening pipe.</span>
  <span class="keywordflow">if</span> ( role == role_base || role == role_relay )
  {
    <span class="comment">// First child listening pipe is #1</span>
    uint8_t current_pipe = 1;
  
    <span class="comment">// The topology table tells us who our children are</span>
    <span class="keywordtype">int</span> i = num_nodes;
    <span class="keywordflow">while</span> (i--)
    {
      <span class="keywordflow">if</span> ( topology[i].parent_node == node_address )
        radio.openReadingPipe(current_pipe++,topology[i].talking_pipe);
    }
  }
  
  <span class="comment">//</span>
  <span class="comment">// Start listening</span>
  <span class="comment">//</span>
  
  radio.startListening();
  
  <span class="comment">//</span>
  <span class="comment">// Dump the configuration of the rf unit for debugging</span>
  <span class="comment">//</span>
  
  radio.printDetails();

  <span class="comment">//</span>
  <span class="comment">// Prompt the user to assign a node address if we don&#39;t have one</span>
  <span class="comment">//</span>

  <span class="keywordflow">if</span> ( role == role_invalid )
  {
    printf(<span class="stringliteral">&quot;\n\r*** NO NODE ADDRESS ASSIGNED *** Send 0 through 5 to assign an address\n\r&quot;</span>);
  }
}

<span class="keywordtype">void</span> ping_if_ready(<span class="keywordtype">void</span>);
<span class="keywordtype">void</span> handle_pong(<span class="keyword">const</span> payload_t&amp; payload);
<span class="keywordtype">void</span> check_pong_timeout(<span class="keywordtype">void</span>);

<span class="keywordtype">void</span> loop(<span class="keywordtype">void</span>)
{
  <span class="comment">//</span>
  <span class="comment">// Leaf role.  Repeatedly send the current time</span>
  <span class="comment">//</span>
  
  <span class="keywordflow">if</span> ( role == role_leaf ) 
  {
    ping_if_ready();
    check_pong_timeout();

    <span class="comment">// Did we get a pong?</span>
    <span class="keywordflow">if</span> ( radio.available() )
    {
      <span class="comment">// Dump the payloads until we&#39;ve gotten everything</span>
      payload_t payload;
      <span class="keywordtype">boolean</span> done = <span class="keyword">false</span>;
      <span class="keywordflow">while</span> (!done)
      {
        <span class="comment">// Fetch the payload, and see if this was the last one.</span>
        done = radio.read( &amp;payload, <span class="keyword">sizeof</span>(payload_t) );

        handle_pong(payload);
      }  
    }
  }
  
  <span class="comment">//</span>
  <span class="comment">// Relay role.  Forward packets to the appropriate destination</span>
  <span class="comment">//</span>

  <span class="keywordflow">if</span> ( role == role_relay )
  {
<span class="preprocessor">#if 1    </span>
<span class="preprocessor"></span>    <span class="comment">// Relay role is ALSO a ping sender!!</span>
    ping_if_ready();    
    check_pong_timeout();
<span class="preprocessor">#endif</span>
<span class="preprocessor"></span>    <span class="comment">// if there is data ready</span>
    uint8_t pipe_num;
    <span class="keywordflow">if</span> ( radio.available(&amp;pipe_num) )
    {
      <span class="comment">// Dump the payloads until we&#39;ve gotten everything</span>
      payload_t payload;
      <span class="keywordtype">boolean</span> done = <span class="keyword">false</span>;
      <span class="keywordflow">while</span> (!done)
      {
        <span class="comment">// Fetch the payload, and see if this was the last one.</span>
        done = radio.read( &amp;payload, <span class="keyword">sizeof</span>(payload_t) );

        <span class="comment">// Is this for us?</span>
        <span class="keywordflow">if</span> ( payload.to_node == node_address )
        {
          handle_pong(payload);
        }
        <span class="keywordflow">else</span>
        {
          <span class="comment">// Relay it</span>
          
          <span class="comment">// Spew it</span>
          printf(<span class="stringliteral">&quot;%lu &quot;</span>,millis());
          payload_printf(<span class="stringliteral">&quot;RELAY&quot;</span>,payload);
          printf(<span class="stringliteral">&quot; on pipe %u. &quot;</span>,pipe_num);

          <span class="comment">// Which pipe should we use to get the message to the &quot;to_node&quot;?</span>
          <span class="comment">// We need to find a node who is OUR CHILD that either IS the to_node</span>
          <span class="comment">// or has the to_node as one of ITS children.  Failing that, we&#39;ll just</span>
          <span class="comment">// send it back to the parent to deal with.</span>
          uint8_t out_node = find_node(node_address,payload.to_node);

          <span class="comment">// First, stop listening so we can talk</span>
          radio.stopListening();

          <span class="comment">// If this node is our child, we talk on it&#39;s listening pipe.</span>
          uint64_t out_pipe;
          <span class="keywordflow">if</span> ( topology[out_node].parent_node == node_address )
            out_pipe = topology[out_node].listening_pipe;
          
          <span class="comment">// Otherwise, it&#39;s our parent so we talk on OUR talking pipe</span>
          <span class="keywordflow">else</span>
            out_pipe = topology[node_address].talking_pipe;
          
          <span class="comment">// Open the correct pipe for writing.  </span>
          radio.openWritingPipe(out_pipe);
      
          <span class="comment">// Send the payload back out </span>
          <span class="keywordtype">bool</span> ok = radio.write( &amp;payload, <span class="keyword">sizeof</span>(payload_t) );
      
          <span class="comment">// Debug spew </span>
          uint16_t pipe_id = out_pipe &amp; 0xffff;
          printf(<span class="stringliteral">&quot;OUT on pipe %04x %s.\n\r&quot;</span>,pipe_id,ok?<span class="stringliteral">&quot;ok&quot;</span>:<span class="stringliteral">&quot;failed&quot;</span>);
          
          <span class="comment">// Now, resume listening so we catch the next packets.</span>
          radio.startListening();
        }
      }
    }
  }
  
  <span class="comment">//</span>
  <span class="comment">// Base role.  Receive each packet, dump it out, and send it back</span>
  <span class="comment">//</span>
  
  <span class="keywordflow">if</span> ( role == role_base )
  {
    <span class="comment">// if there is data ready</span>
    uint8_t pipe_num;
    <span class="keywordflow">if</span> ( radio.available(&amp;pipe_num) )
    {
      <span class="comment">// Dump the payloads until we&#39;ve gotten everything</span>
      payload_t ping;
      <span class="keywordtype">boolean</span> done = <span class="keyword">false</span>;
      <span class="keywordflow">while</span> (!done)
      {
        <span class="comment">// Fetch the payload, and see if this was the last one.</span>
        done = radio.read( &amp;ping, <span class="keyword">sizeof</span>(payload_t) );
  
        <span class="comment">// Spew it</span>
        printf(<span class="stringliteral">&quot;%lu &quot;</span>,millis());
        payload_printf(<span class="stringliteral">&quot;PING&quot;</span>,ping);
        printf(<span class="stringliteral">&quot; on pipe %u. &quot;</span>,pipe_num);

        <span class="comment">// Track the packets lost since we last heard from this node</span>
        <span class="comment">// Packet loss is generally a sign of poor system health</span>
        uint16_t* last_id_ptr = &amp;last_id_received[ping.from_node];
        <span class="keywordflow">if</span> ( *last_id_ptr &amp;&amp; ping.id &gt; *last_id_ptr )
        {
          uint16_t lost = ping.id - *last_id_ptr - 1;
          <span class="keywordflow">if</span> ( lost )
            printf(<span class="stringliteral">&quot; lost %u&quot;</span>,lost);
        }
        *last_id_ptr = ping.id;
      }
      
      <span class="comment">// First, stop listening so we can talk</span>
      radio.stopListening();
      
      <span class="comment">// Construct the return payload (pong)</span>
      payload_t pong(node_address,ping.from_node,ping.time);

      <span class="comment">// Find the correct pipe for writing.  We can only talk on one of our</span>
      <span class="comment">// direct children&#39;s listening pipes.  If the to_node is further out,</span>
      <span class="comment">// it will get relayed.</span>
      uint8_t out_node = find_node(node_address,pong.to_node);

      <span class="comment">// Open the correct pipe for writing</span>
      radio.openWritingPipe(topology[out_node].listening_pipe);

      <span class="comment">// Retain the low 2 bytes to identify the pipe for the spew</span>
      uint16_t pipe_id = topology[out_node].listening_pipe &amp; 0xffff;
            
      <span class="comment">// Send the final one back.</span>
      <span class="keywordtype">bool</span> ok = radio.write( &amp;pong, <span class="keyword">sizeof</span>(payload_t) );  
      payload_printf(<span class="stringliteral">&quot; ...PONG&quot;</span>,pong);
      printf(<span class="stringliteral">&quot; on pipe %04x %s.\n\r&quot;</span>,pipe_id,ok?<span class="stringliteral">&quot;ok&quot;</span>:<span class="stringliteral">&quot;failed&quot;</span>);
      
      <span class="comment">// Now, resume listening so we catch the next packets.</span>
      radio.startListening();
    }
  }
  

  <span class="comment">//</span>
  <span class="comment">// Listen for serial input, which is how we set the address</span>
  <span class="comment">//</span>
  <span class="keywordflow">if</span> (Serial.available())
  {
    <span class="comment">// If the character on serial input is in a valid range...</span>
    <span class="keywordtype">char</span> c = Serial.read();
    <span class="keywordflow">if</span> ( c &gt;= <span class="charliteral">&#39;0&#39;</span> &amp;&amp; c &lt;= <span class="charliteral">&#39;5&#39;</span> )
    {
      <span class="comment">// It is our address</span>
      EEPROM.write(address_at_eeprom_location,valid_eeprom_flag);
      EEPROM.write(address_at_eeprom_location+1,c-<span class="charliteral">&#39;0&#39;</span>);

      <span class="comment">// And we are done right now (no easy way to soft reset)</span>
      printf(<span class="stringliteral">&quot;\n\rManually reset address to: %c\n\rPress RESET to continue!&quot;</span>,c);
      <span class="keywordflow">while</span>(1);
    }
  }
}

<span class="keywordtype">void</span> ping_if_ready(<span class="keywordtype">void</span>)
{
  <span class="comment">// Is it time to ping again?</span>
  <span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> now = millis();
  <span class="keywordflow">if</span> ( now - last_ping_sent_at &gt;= ping_interval )
  {
    last_ping_sent_at = now;
    waiting_for_pong = <span class="keyword">true</span>;

    <span class="comment">// First, stop listening so we can talk.</span>
    radio.stopListening();

    <span class="comment">// Write on our talking pipe.  The relay has to do this every time, because</span>
    <span class="comment">// we ALSO use pipe 0 as a listening pipe.</span>
    radio.openWritingPipe(topology[node_address].talking_pipe);
    
    <span class="comment">// Take the time, and send it to the base.  This will block until complete</span>
    payload_t ping(node_address,0,millis());

    <span class="comment">// Print details.</span>
    printf(<span class="stringliteral">&quot;%lu &quot;</span>,millis());
    payload_printf(<span class="stringliteral">&quot;&gt;PING&quot;</span>,ping);
    <span class="keywordtype">bool</span> ok = radio.write( &amp;ping, <span class="keyword">sizeof</span>(payload_t) );  
    <span class="keywordflow">if</span> (ok)
      printf(<span class="stringliteral">&quot; ok\n\r&quot;</span>);
    <span class="keywordflow">else</span>
      printf(<span class="stringliteral">&quot; failed\n\r&quot;</span>);

    <span class="comment">// Now, continue listening</span>
    radio.startListening();
  }
}

<span class="keywordtype">void</span> handle_pong(<span class="keyword">const</span> payload_t&amp; payload)
{
  <span class="comment">// Not waiting anymore, got one.</span>
  waiting_for_pong = <span class="keyword">false</span>;
  consecutive_timeouts = 0;

  <span class="comment">// Print details.</span>
  printf(<span class="stringliteral">&quot;%lu &quot;</span>,millis());
  payload_printf(<span class="stringliteral">&quot;&gt;PONG&quot;</span>,payload);
  printf(<span class="stringliteral">&quot; Round-trip delay: %lu\n\r&quot;</span>,millis()-payload.time);
}

<span class="keywordtype">void</span> check_pong_timeout(<span class="keywordtype">void</span>)
{
  <span class="comment">// Have we timed out waiting for our pong?</span>
  <span class="keywordflow">if</span> ( waiting_for_pong &amp;&amp; ( millis() - last_ping_sent_at &gt; pong_timeout ) )
  {
    <span class="comment">// Not waiting anymore, timed out.</span>
    waiting_for_pong = <span class="keyword">false</span>;

    <span class="comment">// Timeouts usually happen because of collisions with other nodes</span>
    <span class="comment">// getting a pong just as we are trying to send a ping.  The best thing</span>
    <span class="comment">// to do right now is offset our ping timing to search for a slot</span>
    <span class="comment">// that&#39;s not occupied.</span>
    <span class="comment">//</span>
    <span class="comment">// Only do this after getting a few timeouts, so we aren&#39;t always skittishly</span>
    <span class="comment">// moving around the cycle.</span>
    <span class="keywordflow">if</span> ( ++consecutive_timeouts &gt; timeout_shift_threshold )
      last_ping_sent_at += ping_phase_shift; 

    <span class="comment">// Print details</span>
    printf(<span class="stringliteral">&quot;%lu &quot;</span>,millis());
    printf(<span class="stringliteral">&quot;TIMED OUT.\n\r&quot;</span>);
  }
}
<span class="comment">// vim:ai:cin:sts=2 sw=2 ft=cpp</span>
</pre></div> </div>
</div>
<!--- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
<a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(0)"><span class="SelectionMark">&#160;</span>All</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(1)"><span class="SelectionMark">&#160;</span>Classes</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(2)"><span class="SelectionMark">&#160;</span>Functions</a></div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<hr class="footer"/><address class="footer"><small>Generated on Wed May 25 2011 22:22:40 for RF24 by&#160;
<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.7.3 </small></address>
</body>
</html>
